#!/usr/bin/env python

import os
import sys
import yaml
import rospy
import numpy as np
import copy


import rospkg 
rospack = rospkg.RosPack()



def merge_two_dicts(x, y):
    z = x.copy()   # start with x's keys and values
    z.update(y)    # modifies z with y's keys and values & returns None
    return z


class SkillBuilder:
    def __init__(self, context=None, skill_package='pressure_controller_skills', skill_folder="skills"):
        curr_path = rospack.get_path(skill_package)
        #curr_path=os.path.dirname(os.path.abspath(__file__))
        filepath_in = os.path.join(curr_path,skill_folder)
        filepath_out = os.path.join(curr_path,'.'+skill_folder)
        self.filepath_in = filepath_in
        self.filepath_out = filepath_out
        self.controller_context = context
        self.skill_config = None


    # Load the skill definition intoa python dictionary
    def load_skill(self,filename):
        config_file = os.path.join(self.filepath_in,filename+'.yaml')

        if os.path.isfile(config_file):
            with open(config_file,'r') as f:
                self.skill_config = yaml.safe_load(f)
        else:
            self.skill_config = None
            print(config_file)
            print("Skill config file cannot be found")

        return self.skill_config


    def set_skill_config(self, skill_config):
        self.skill_config = skill_config


    def get_skill_config(self):
        return self.skill_config


    # Compile the skill from the definition
    def generate_skill(self, vars=None, times=None):
        variables = self.skill_config.get('variables', None)
        postures = self.skill_config.get('postures', None)
        skill = self.skill_config.get('skill', None)
        skill_times = skill.get('default_times', None)
        context_curr = self.skill_config.get('context', None)

        if (variables is None) or (postures is None) or (skill is None):
            raise ValueError("Skill definition is invalid")
            return

        if not self._validate_context(context_curr):
            raise ValueError("Skill is not valid in context %s"%(context_curr))
            return


        # Assimilate variables into defaults:
        if isinstance(vars,dict):
            variables = merge_two_dicts(variables,vars)

        # Compile postures based on equations
        postures_compiled = {}
        for key in postures:
            if not isinstance(postures[key], list):
                print('Posture definition "%s" is not a list'%(key))
                continue

            postures_compiled[key] = []
            for equation in postures[key]:
                postures_compiled[key].append(
                    self._substitute_variables(equation,variables)
                )
                

        self.postures_compiled = postures_compiled

        # Assimilate skill timings
        if isinstance(times,dict):
            skill_times = merge_two_dicts(skill_times,times)


        self.skill_compiled = self._compile_skill(skill,skill_times)
        self.skill_def_compiled = {'skill':self.skill_compiled,
                                   'context':context_curr,
                                   'postures':postures_compiled}


        return self.skill_def_compiled


    # Compile skill from times
    def _compile_skill(self,skill,times):
        skill_compiled = {}
        for key in skill:
            if key == 'default_times':
                continue
            
            if not isinstance(skill[key], list):
                print('Skill subcomponent "%s" is not a list'%(key))
                continue

            if len(skill[key])<1:
                print('Skill subcomponent "%s" is empty'%(key))
                continue
            
            def_last_time = skill[key][-1]['time']
            time_goal=times.get(key, 1.0)

            skill_compiled[key] = []

            for row in skill[key]:
                new_row=copy.deepcopy(row)
                new_row['pressure'] = new_row.pop('posture')
                new_row['time'] = row['time']*time_goal/def_last_time
                skill_compiled[key].append(new_row)

        return skill_compiled
            
            


    # Save the skill in a yaml file for use later 
    def save_skill(self, filename):
        outfile = os.path.join(self.filepath_out,filename+'.skill')
        outdir = os.path.dirname(outfile)
        if not os.path.exists(outdir):
            try:
                os.makedirs(outdir)
            except OSError as exc: # Guard against race condition
                if exc.errno != errno.EEXIST:
                    raise

        with open(outfile, 'w+') as f:
            f.write('# This file was automatically generated by the pressure_controller_skills package\n# (https://github.com/cbteeple/pressure_controller_skills)\n# DO NOT EDIT THIS FILE DIRECTLY UNLESS YOU KNOW WHAT YOU ARE DOING!\n\n')
            yaml.dump(self.skill_def_compiled, f, default_flow_style=None)


    # Check if the current skill is valid in the current controller context
    def _validate_context(self, context):
        if self.controller_context is None:
            return True
        elif self.controller_context in context:
            return True
        else:
            return False



    # Substitute variable values into equations and evaluate them
    def _substitute_variables(self, equation, variables):
        for var_key in variables:
            equation = equation.replace(var_key,str(variables[var_key]))
        
        return eval(equation)
        

    def shutdown(self):
        pass
           


        

